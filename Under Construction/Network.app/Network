#!/usr/bin/env python3


# TODO: List the different wireless interfaces with `wpa_cli interface` if there is more than one

# TODO: Allow to "open a hotspot":
# FreeBSD can act as an Access Point (AP) which eliminates the need to buy a hardware AP or run an ad-hoc network.
# This can be particularly useful when a FreeBSD machine is acting as a gateway to another network such as the Internet.
# https://vzaigrin.wordpress.com/2014/08/04/how-to-setup-wireless-access-point-on-raspberry-pi-running-freebsd/
# https://github.com/opnsense/src/blob/master/tools/tools/net80211/scripts/setup.simple2
# "WPA2 Host-based Access Point"
# https://docs.freebsd.org/en/books/handbook/advanced-networking/#network-wireless


from ctypes import cast, POINTER, c_uint32
from PyQt5.sip import voidptr
from PyQt5.QtWidgets import QApplication, QSystemTrayIcon, QMenu, QAction, QHBoxLayout, QWidget, QActionGroup, \
    QMessageBox, QLineEdit, QStyle, QStyleOptionMenuItem, QLabel, QWidgetAction, QProxyStyle, QDialog, \
    QGridLayout, QLayout, QCheckBox, QPushButton, QSizePolicy
from PyQt5.QtGui import QIcon, QPixmap, QCursor, QPainter, QPaintEvent, QImage, qGray, qAlpha, qRgba
from PyQt5.QtCore import Qt, QProcess, QObject, QTimer, QSize, QFileSystemWatcher
from collections import namedtuple
import sys, os, re


def run_command_and_get_output(command: str, args, process: QProcess = None) -> str:
    if process is None:
        process = QProcess()

    process.setProgram(command)
    process.setArguments(args)
    print(process.program() + " " + " ".join(process.arguments()))
    process.start()
    process.waitForFinished()
    return str(process.readAllStandardOutput(), 'UTF-8')


WIRED_CONNECTED = 0
WIRED_DISCONNECTED = 1
WIRED_OFFLINE = 2


def get_pixmap_for_wired_status(status: int) -> QPixmap:
    if status == WIRED_CONNECTED:
        icon_name = "network-wired-symbolic"
    elif status == WIRED_DISCONNECTED:
        icon_name = "network-wired-disconnected-symbolic"  # Same as "network-wired-offline-symbolic"
    else:
        icon_name = "network-wired-no-route-symbolic"

    return get_tray_icon_with_color(icon_name)


def get_pixmap_for_wpa_status(status: str, signal_level: int) -> QPixmap:
    # https://w1.fi/wpa_supplicant/devel/defs_8h.html#a4aeb27c1e4abd046df3064ea9756f0bca6304c99164cf51fa8baecf8b124c6117
    if status == "SCANNING" or status == "ASSOCIATING":
        icon_name = "network-wireless-acquiring-symbolic"
    elif status == "COMPLETED":
        # https://github.com/maxatome/wifimgr/blob/ca9951f0c08a72ad3f36c98a970414219d5b9b03/src/wifimgr-gtk.c#L1312
        if signal_level > 80:
            icon_name = "network-wireless-signal-excellent-symbolic"
        elif signal_level > 60:
            icon_name = "network-wireless-signal-good-symbolic"
        elif signal_level > 40:
            icon_name = "network-wireless-signal-ok-symbolic"
        elif signal_level > 20:
            icon_name = "network-wireless-signal-weak-symbolic"
        elif signal_level > 0:
            icon_name = "network-wireless-signal-none-symbolic"
        else:
            icon_name = "network-wireless-signal-none-symbolic"
    elif status == "INTERFACE_DISABLED":
        icon_name = "network-wireless-no-route-symbolic"
    else:
        icon_name = "network-wireless-offline-symbolic"

    return get_tray_icon_with_color(icon_name)


def get_tray_icon_with_color(icon_name: str) -> QPixmap:
    icon = QIcon.fromTheme(icon_name)
    pixmap: QPixmap = icon.pixmap(QSize(16, 16))
    image = pixmap.toImage()
    # Use 100 on this icon set for a gray color that looks similar to the rest of the icons on the system tray
    return QPixmap.fromImage(set_monochrome_image_color(image, 100))


# https://github.com/helloSystem/Menu/blob/c13548d3866c3896d728d2388bd0d4cd636a3a91/plugin-statusnotifier/statusnotifierbutton.cpp#L108
def set_monochrome_image_color(src_image: QImage, rgb_value: int=-1) -> QImage:
    image: QImage = src_image.convertToFormat(QImage.Format_ARGB32 if src_image.hasAlphaChannel() else QImage.Format_RGB32)
    pointer: voidptr = image.bits()
    pixel_array = cast(pointer.__int__(), POINTER(c_uint32))
    pixel_count = image.width() * image.height()

    for i in range(pixel_count):
        pixel = pixel_array.__getitem__(i)

        value = rgb_value
        if rgb_value == -1:
            value = qGray(pixel)

        value = qRgba(value, value, value, qAlpha(pixel))
        pixel_array.__setitem__(i, value)

    return image


# Only need this for now
NetworkInfo = namedtuple("NetworkInfo", ["flags", "signal_level"])


def get_network_info(bssid: str) -> NetworkInfo:
    lines = run_command_and_get_output("wpa_cli", ["bss", bssid]).strip().splitlines()

    signal_strength_dbm = 0
    signal_noise_dbm = 0
    flags = ""
    for line in lines:
        if line.startswith("noise="):
            signal_noise_dbm = int(line.split("=")[1])
        elif line.startswith("level="):
            signal_strength_dbm = int(line.split("=")[1])
        elif line.startswith("flags="):
            flags = line.split("=")[1]

    # https://github.com/maxatome/wifimgr/blob/ca9951f0c08a72ad3f36c98a970414219d5b9b03/src/wifimgr.c#L848
    return NetworkInfo(flags, (signal_strength_dbm - signal_noise_dbm) * 4)


def request_network_password(dialog_text: str) -> tuple[str, bool]:
    dialog = PasswordRequestDialog(dialog_text)
    dialog.setWindowTitle("Wireless network password")

    ok, password = dialog.get_password()
    if not ok:
        print("User did not click OK in password dialog")

    return password, ok


class NetworkMenu(QObject):

    def __init__(self):

        super().__init__()

        # self.showTODO("It can show wireless networks but not connect to them. Do you know how to fix this?")
        self.showTODO()

        self.tray = QSystemTrayIcon()

        self.tray.setVisible(True)
        self.menu = QMenu()
        self.wirelessGroup = QActionGroup(self.menu)  # Only one of the actions added to this group can be active

        self.tray.setContextMenu(self.menu)
        self.tray.activated.connect(self.show_menu)

        # NOTE:
        # https://forum.learnpyqt.com/t/qsystemtrayicon-example/689
        # Sneaky PyQt quirk! A reference to the actions must be kept around or the actions will be destroyed
        self.actions = []
        self.sliderWindow = None
        self.check_network_password = False
        self.updateStatus()
        
        self.timer = QTimer()
        self.timer.setInterval(3000)  # Every 3 seconds
        self.timer.timeout.connect(self.updateStatus)
        self.timer.start()

        log_file_watcher = QFileSystemWatcher(["/var/log/messages"], self)
        log_file_watcher.fileChanged.connect(self.read_log_file)

        self.refreshMenu()  # Initially populate the menu
        self.tray.installEventFilter(self) # FIXME: This never seems to get called, why?
        self.installEventFilter(self)  # FIXME: This never seems to get called, why?

    def eventFilter(self, obj, event) -> bool:
        print("eventFilter function running")  # FIXME: Why is this never called when the icon is right-clicked?
        # We need to refresh the contents of the right-click menu somehow when the user right-clicks...
        return super().eventFilter(obj, event)

    def show_menu(self, reason):
        self.updateMenu()
        if reason == QSystemTrayIcon.Trigger:
            # Ideally we would just tell it when it gets left-clicked
            # to just do whatever it does when it gets right-clicked, but:
            # self.tray.activated(QSystemTrayIcon.Context) # TypeError: native Qt signal is not callable
            print(self.tray.geometry().getRect()) # Always returns (0, 0, 0, 0); why?
            # self.menu.popup(QPoint(self.tray.geometry().x(), self.tray.geometry().y())) # Does not work for the same reason
            # self.menu.move(QCursor.pos())
            # self.menu.show() # When called like this, it appears as a context menu over the menu bar, which is not desired
            # self.menu.activateWindow() # Needed on some systems to make the menu go away when clicked anywhere else but in the menu?
            self.menu.popup(QCursor.pos()) # When called like this, it appears almost at the correct location but with the wrong font size,
            # as if it was a context menu rather than a real menu; probably because somehow its parent now is not the global menu bar main window?

    def refreshMenu(self):
        self.actions = []
        # Get the networks from wpa_cli
        p = QProcess()
        p.setProgram("wpa_cli")

        # First, scan
        p.setArguments(["scan"])
        print(p.program() + " " + " ".join(p.arguments()))
        p.start()
        p.waitForFinished()

    def updateStatus(self):
        bssid = ""
        status = ""
        p = QProcess()
        interfaces = run_command_and_get_output("ifconfig", ["-l", "ether"], p).strip().split(' ')

        wlan_present = False
        wired_status = -1
        if len(interfaces) == 0:
            self.tray.setIcon(QIcon(get_pixmap_for_wired_status(WIRED_OFFLINE)))

        for i in interfaces:
            # wpa_cli takes care of wireless interfaces
            if "wlan" in i:
                wlan_present = True
                continue

            output = run_command_and_get_output("ifconfig", [i, "inet"], p)

            # If it doesn't have an IPv4 address then "inet" is not present, but "inet6" is always there, does that
            # mean that it always has an IPv6 address? Is it the MAC address?
            if "inet" in output:
                wired_status = WIRED_CONNECTED
            else:
                wired_status = WIRED_DISCONNECTED

        if not wlan_present:
            self.tray.setIcon(QIcon(get_pixmap_for_wired_status(wired_status)))
            return

        self.status_lines = run_command_and_get_output("wpa_cli", ["status"]).strip().splitlines()
        print(self.status_lines)
        
        # Update the icon in the menu
        for element in self.status_lines:
            if element.startswith("bssid="):
                bssid = element.split("=")[1]
            elif element.startswith("wpa_state="):
                status = element.split("=")[1]
                break

        if status == "COMPLETED":
            self.check_network_password = False

        if wired_status == WIRED_CONNECTED:
            icon_pixmap = get_pixmap_for_wired_status(wired_status)
        else:
            icon_pixmap = get_pixmap_for_wpa_status(status, get_network_info(bssid).signal_level)

        self.tray.setIcon(QIcon(icon_pixmap))

        if not self.menu.isHidden():
            for action in self.menu.actions():
                if hasattr(action, "bssid"):
                    network_info = get_network_info(getattr(action, "bssid"))
                    action.defaultWidget().set_signal_level(network_info.signal_level)
                    action.defaultWidget().set_password_protected("PSK" in network_info.flags)

    def updateMenu(self):
    
        # Find out whether we are connected to one of the networks
        self.updateStatus()
    
        self.menu.clear()
        # Second, show
        lines = run_command_and_get_output("wpa_cli", ["scan_results"]).strip().splitlines()

        action = QAction("Wireless")
        action.setDisabled(True)
        self.actions.append(action)
        self.menu.addAction(action)
        
        if len(lines) > 1:
            ssids_added_to_menu = []
            for line in lines:
                if line.startswith("Selected") or line.startswith("bssid"):
                    continue
                print(line)
                # Parse out information for each network
                regex = r"([^\ ]+)\t[^\ ]+\t[^\ ]+\t([^\ ]+)\t(.*)$"
                matches = re.findall(regex, line)
                if not matches:
                    continue
                print(len(matches[0]))
                bssid = matches[0][0]
                flags = matches[0][1]
                label = matches[0][2]
                signal_level = get_network_info(bssid).signal_level

                ssid = label
                if label == "" or label.startswith("\\x00"):
                    label = bssid  # For networks with hidden ssid (network name)
                action = QWidgetAction(self.menu)
                action.__setattr__("ssid", ssid)
                action.__setattr__("bssid", bssid)
                # if 'flags' in vars():
                action.__setattr__("flags", flags)
                action.triggered.connect(self.switchNetwork)  # lambda could be used to pass an argument but the argument passed is taken at the time when this executes, which is not what we want
                action.setCheckable(True)
                action.setText(label)

                item = NetworkItem(self.menu, action)
                item.set_password_protected("PSK" in flags)
                item.set_signal_level(signal_level)
                action.setDefaultWidget(item)

                if "bssid=" + bssid in self.status_lines:
                    action.setChecked(True)

                # TODO: Show networks with same SSID but different BSSID
                if ssid not in ssids_added_to_menu:
                    self.actions.append(action)
                    self.wirelessGroup.addAction(action)
                    self.menu.addAction(action)
                    ssids_added_to_menu.append(ssid)

        self.menu.addSeparator()

        action = QAction("Rescan Networks")
        # action.setDisabled(True)
        action.triggered.connect(self.refreshMenu)
        self.actions.append(action)
        self.menu.addAction(action)

        action = QAction("Create Hotspot...")  # TODO: To be implemented
        action.setDisabled(True)
        self.actions.append(action)
        self.menu.addAction(action)

        action = QAction("Disconnect")
        if "wpa_state=COMPLETED" in self.status_lines:
            action.setDisabled(False)
        else:
            action.setDisabled(True)
        action.triggered.connect(self.disconnect)
        self.actions.append(action)
        self.menu.addAction(action)

        self.menu.addSeparator()

        action = QAction("About")
        action.triggered.connect(self._showAbout)
        self.actions.append(action)
        self.menu.addAction(action)

    def reconnect(self):
        print(run_command_and_get_output("wpa_cli", ["reconnect"]))
         
    def disconnect(self):
        print(run_command_and_get_output("wpa_cli", ["disconnect"]))
        # self.tray.setIcon(QIcon.fromTheme("network-wireless-offline-symbolic"))
        
    def switchNetwork(self, line):
        # TODO: Support networks protected with EAP
        self.check_network_password = False
        self.updateStatus()
    
        ssid = getattr(self.wirelessGroup.checkedAction(), "ssid")
        bssid = getattr(self.wirelessGroup.checkedAction(), "bssid")
        flags = getattr(self.wirelessGroup.checkedAction(), "flags")
        
        # self.reconnect()
            
        # Get a byte string with wpa_cli's output and decode it
        p = QProcess()
        # Split that output into lines, ignoring the useless ones
        output = run_command_and_get_output("wpa_cli", ["list_networks"], p)
        network_list = output.strip().splitlines()
        if len(network_list) < 2:
            # If this is called, something is wrong with wpa_cli.
            self.showError("Could not connect to the network", """For some reason wpa_cli doesn't seem to be working.

Information for debuggers:
""" + output.strip())
            return
        is_used = False
        for line in network_list[2:]:  # Ignore 'selected interface' message and column labels
            parts = line.split('\t')
            if parts[1] in [ssid, bssid]:
                key_mgmt = run_command_and_get_output("wpa_cli", ["get_network", parts[0], "key_mgmt"],
                                                      p).strip().splitlines()[1]

                # Accept if the same authentication method is used, treat as different network if not.
                # Not handling IEEE8021X
                if ("WPA" in flags) == ("WPA" in key_mgmt):
                    is_used = True
                    self.network_id = parts[0]
                    break

        if is_used: # TODO: We know we've already connected -- check why we are re-connecting
            if "PSK" in flags:
                self.check_network_password = True

            p.setArguments(["select_network", str(self.network_id)])
            p.start()
            p.waitForFinished()
        else:
            output = run_command_and_get_output("wpa_cli", ["add_network"], p).strip().splitlines()[-1]
            if not output.isnumeric():
                self.showError("Could not connect to the network.", "'%s' is not a number." % output)
                print("'%s' is not a number." % output)
                return # bad
            try:
                self.network_id = int(output)
            except:
                self.showError("Could not connect to the network.", "\
We don't know why this happened.")
                print("returned non-zero exit code")
                return  # bad

            if ssid:
                identifier = "ssid"
                identifier_str = ssid
            else:
                identifier = "bssid"
                identifier_str = bssid

            output = run_command_and_get_output(
                "wpa_cli",
                ["set_network", str(self.network_id), identifier, "\"%s\"" % identifier_str],
                p)

            if "OK" not in output:
                self.showError("Could not connect to the network.",
                               """Information for debuggers: """ + output)
                return # bad
            if "PSK" in flags:
                password, ok = request_network_password(
                    "<h4>Please enter the password for the \"%s\" network:</h4>" % ssid if ssid else bssid)
                if ok:
                    p.setArguments(["set_network", str(self.network_id), "psk", "\"%s\"" % password])
                else:
                    p.setArguments(["remove_network", str(self.network_id)])
                    p.start()
                    p.waitForFinished()
                    return
            else:
                p.setArguments(["set_network", str(self.network_id), "key_mgmt", "NONE"])

            print(p.program() + " " + " ".join(p.arguments()))
            p.start()
            p.waitForFinished()
            output = str(p.readAllStandardOutput(), 'utf-8')
            if "OK" not in output:
                self.showError("Could not connect to the network. Please check the password.",
                               """Information for debuggers: """ + output)
                return # not good

            output = run_command_and_get_output("wpa_cli", ["enable_network", str(self.network_id)], p)
            if "OK" in output:
                p.setArguments(["save_config"])
                print(p.program() + " " + " ".join(p.arguments()))
                p.start()
                p.waitForFinished()
                return # good
            else:
                self.showError("Could not connect to the network. Please check the password.",
                               """Information for debuggers: """ + output)
                return # not good

    def _showAbout(self):
        print("showDialog")
        msg = QMessageBox()
        msg.setWindowTitle("Network")
        msg.setIconPixmap(QPixmap(os.path.dirname(__file__) + "/Resources/Network.png").scaledToWidth(64, Qt.SmoothTransformation))
        candidates = ["COPYRIGHT", "COPYING", "LICENSE"]
        for candidate in candidates:
            if os.path.exists(os.path.dirname(__file__) + "/" + candidate):
                with open(os.path.dirname(__file__) + "/" + candidate, 'r') as file:
                    data = file.read()
                msg.setDetailedText(data)
        msg.setText("<h3>Network</h3>")
        msg.setInformativeText("A simple QSystemTrayIcon application to select the wireless network using <a href='https://www.freebsd.org/cgi/man.cgi?wpa_cli'>wpa_cli</a><br><br><a href='https://github.com/helloSystem/Utilities'>https://github.com/helloSystem/Utilities</a>")
        msg.exec()

    def showError(self, text, detailed_text=""):
        msg = QMessageBox()
        msg.setIcon(QMessageBox.Critical)
        msg.setWindowTitle("Error")
        msg.setText(text)
        if detailed_text != "":
            msg.setDetailedText(detailed_text)
        msg.exec()

    def showTODO(self, detailed_text=""):
        msg = QMessageBox()
        msg.setIcon(QMessageBox.Information)
        msg.setWindowTitle("Developer Preview")
        msg.setText("This application is a preview for developers.<br>It is not fully functional yet.")
        msg.setDetailedText("Please see https://github.com/helloSystem/Utilities if you would like to contribute.\n\n" + detailed_text)
        msg.exec()

    def read_log_file(self, path):
        output = ""

        # Read last line of file
        with open(path, 'rb') as file:
            try:
                file.seek(-2, os.SEEK_END)
                while file.read(1) != b'\n':
                    file.seek(-2, os.SEEK_CUR)
            except OSError:
                file.seek(0)
            output = file.readline().decode()

        if self.check_network_password and self.wirelessGroup.checkedAction() and\
                ("ssid=\"%s\"" % getattr(self.wirelessGroup.checkedAction(), "ssid")) and "reason=WRONG_KEY" in output:
            ssid = getattr(self.wirelessGroup.checkedAction(), "ssid")
            bssid = getattr(self.wirelessGroup.checkedAction(), "bssid")
            self.disconnect()  # Prevent wpa_supplicant from trying to connect and fail again

            password, ok = request_network_password("<h4>Please enter the password for the \"%s\" network:</h4></br>Incorrect password. Please try again." % ssid if ssid else bssid)

            if not ok:
                self.check_network_password = False
                return  # Don't try to connect to a network if it has been cancelled.

            p = QProcess()
            p.setProgram("wpa_cli")
            p.setArguments(["set_network", str(self.network_id), "psk", '"' + password + '"'])
            print(p.program() + " " + " ".join(p.arguments()))
            p.start()
            p.waitForFinished()

            p.setArguments(["save_config"])
            p.start()
            p.waitForFinished()

            self.reconnect()


# https://forum.qt.io/post/367830
class NetworkItem(QWidget):

    # password_protected: bool):
    def __init__(self, parent: QWidget, action: QAction):
        super().__init__(parent)

        self.proxyStyle = QProxyStyle("panda")
        self.action = action

        self.layout = QHBoxLayout()
        self.layout.setAlignment(Qt.AlignTrailing)
        self.layout.setContentsMargins(0, 0, 10, 0)

        self.lock_label = QLabel()
        self.lock_label.setPixmap(QIcon.fromTheme("network-wireless-encrypted-symbolic").pixmap(QSize(14, 14)))
        self.layout.addWidget(self.lock_label)
        self.signal_label = QLabel()
        self.signal_label.setPixmap(QIcon.fromTheme("network-wireless-symbolic").pixmap(QSize(16, 16)))
        self.layout.addWidget(self.signal_label)

        self.setLayout(self.layout)
        self.setMouseTracking(True)

    def set_password_protected(self, password_protected: bool):
        self.lock_label.setVisible(password_protected)

    def set_signal_level(self, signal_level: int):
        self.signal_label.setPixmap(get_pixmap_for_wpa_status("COMPLETED", signal_level))

    def minimumSizeHint(self):
        opt = QStyleOptionMenuItem()
        opt.initFrom(self)
        opt.menuHasCheckableItems = True
        contentSize = self.fontMetrics().size(Qt.TextSingleLine | Qt.TextShowMnemonic, self.action.text())
        return self.style().sizeFromContents(QStyle.CT_MenuItem, opt, contentSize, self)\
            + QSize(self.layout.sizeHint().width(), 0)

    def paintEvent(self, e: QPaintEvent):
        p = QPainter(self)
        p.setFont(self.parent().font())
        opt = QStyleOptionMenuItem()
        QMenu.initStyleOption(self.parent(), opt, self.action)
        #opt.initFrom(self.parent())
        #opt.text = self.text
        #opt.menuHasCheckableItems = True
        #opt.checked = self.checked
        opt.checkType = QStyleOptionMenuItem.NonExclusive
        #opt.menuItemType = QStyleOptionMenuItem.Normal
        #opt.font = self.action.font().resolve(self.parent().font())
        #opt.fontMetrics = QFontMetrics(opt.font)
        #opt.palette = self.parent().palette()

        #if self.rect().contains(self.mapFromGlobal(self.cursor().pos())):
        #    opt.state |= QStyle.State_Selected
        if opt.state & QStyle.State_Selected and opt.state & QStyle.State_Enabled:
            rgb_color = 255
        else:
            rgb_color = 0

        self.lock_label.setPixmap(QPixmap.fromImage(set_monochrome_image_color(self.lock_label.pixmap().toImage(),
                                                                               rgb_color)))
        self.signal_label.setPixmap(QPixmap.fromImage(set_monochrome_image_color(self.signal_label.pixmap().toImage(),
                                                                                 rgb_color)))

        self.proxyStyle.drawControl(QStyle.CE_MenuItem, opt, p, self)


class PasswordRequestDialog(QDialog):
    def __init__(self, text: str):
        super().__init__()

        self.layout = QGridLayout()
        self.layout.setHorizontalSpacing(15)
        self.layout.setSizeConstraint(QLayout.SetFixedSize)

        self.icon_label = QLabel()
        self.icon_label.setPixmap(QPixmap(os.path.dirname(__file__) + "/Resources/Network.png").scaledToWidth(64, Qt.SmoothTransformation))

        self.text_label = QLabel()
        self.text_label.setMaximumWidth(300)
        self.text_label.setContentsMargins(0, 5, 0, 0)
        self.text_label.setText(text)
        self.text_label.setWordWrap(True)

        self.password_label = QLabel()
        self.password_label.setText("Password:")

        self.password_line_edit = QLineEdit()
        self.password_line_edit.setEchoMode(QLineEdit.Password)
        self.password_line_edit.textChanged.connect(self.password_changed)
        self.password_line_edit.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)

        self.show_password_checkbox = QCheckBox()
        self.show_password_checkbox.setText("Show password")
        self.show_password_checkbox.stateChanged.connect(self.show_password_changed)

        self.buttons_layout = QHBoxLayout()
        self.buttons_layout.setContentsMargins(0, 10, 0, 0)
        self.buttons_layout.setSpacing(10)
        self.buttons_layout.setSizeConstraint(QLayout.SetFixedSize)

        self.cancel_button = QPushButton()
        self.cancel_button.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Fixed)
        self.cancel_button.setText("Cancel")
        self.cancel_button.clicked.connect(self.reject)

        self.connect_button = QPushButton()
        self.connect_button.setEnabled(False)
        self.connect_button.setText("Connect")
        self.connect_button.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Fixed)
        self.connect_button.clicked.connect(self.accept)

        self.buttons_layout.addWidget(self.cancel_button)
        self.buttons_layout.addWidget(self.connect_button)

        self.layout.addWidget(self.icon_label, 0, 0, Qt.AlignTop)
        self.layout.addWidget(self.text_label, 0, 1, 1, 2, Qt.AlignTop)
        self.layout.addWidget(self.password_label, 1, 1, Qt.AlignTop)
        self.layout.addWidget(self.password_line_edit, 1, 2, Qt.AlignTop)
        self.layout.addWidget(self.show_password_checkbox, 2, 2, Qt.AlignTop)
        self.layout.addLayout(self.buttons_layout, 3, 2, Qt.AlignTrailing)

        self.setLayout(self.layout)
        self.setModal(True)
        self.setSizeGripEnabled(False)

    def get_password(self) -> tuple[bool, str]:
        self.exec()

        return self.result(), self.password_line_edit.text()

    def password_changed(self, password: str):
        password_length = len(password)
        self.connect_button.setEnabled(password_length > 8)

        if password_length > 63:
            self.password_line_edit.setText(password[:63])

    def show_password_changed(self, state: int):
        self.password_line_edit.setEchoMode(QLineEdit.Normal if state else QLineEdit.Password)

if __name__ == "__main__":

    # Simple singleton:
    # Ensure that only one instance of this application is running by trying to kill the other ones
    p = QProcess()
    p.setProgram("pkill")
    p.setArguments(["-f", os.path.abspath(__file__)])
    cmd = p.program() + " " + " ".join(p.arguments())
    print(cmd)
    p.start()
    p.waitForFinished()

    # https://github.com/helloSystem/ISO/issues/330
    # This requires ifconfig to be setuid so that normal users can run it
    p.setProgram("ifconfig")
    p.setArguments(["wlan0", "down"])
    print(p.program() + " " + " ".join(p.arguments()))
    p.start()
    p.waitForFinished()
    p.setArguments(["wlan0", "up"])
    print(p.program() + " " + " ".join(p.arguments()))
    p.start()
    p.waitForFinished()

    app = QApplication(sys.argv)
    app.setQuitOnLastWindowClosed(False)
    NM = NetworkMenu()
    sys.exit(app.exec_())
